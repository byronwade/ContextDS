/**
 * Token Export Formatters
 * Convert design tokens to various formats: Tailwind, CSS Variables, Figma JSON, Style Dictionary
 */

export interface DesignToken {
  name: string
  value: string
  category: string
  usage?: number
  confidence?: number
  semantic?: string
}

export interface TokenExportOptions {
  prefix?: string
  includeComments?: boolean
  prettify?: boolean
}

/**
 * Export tokens as Tailwind CSS configuration
 */
export function exportToTailwind(tokens: DesignToken[], options: TokenExportOptions = {}): string {
  const { prefix = '', includeComments = true } = options

  const colorTokens = tokens.filter(t => t.category === 'color')
  const spacingTokens = tokens.filter(t => t.category === 'spacing')
  const radiusTokens = tokens.filter(t => t.category === 'radius')
  const shadowTokens = tokens.filter(t => t.category === 'shadow')
  const fontTokens = tokens.filter(t => t.category === 'typography')

  const config = {
    theme: {
      extend: {
        ...(colorTokens.length > 0 && {
          colors: Object.fromEntries(
            colorTokens.map(t => [
              `${prefix}${sanitizeName(t.name)}`,
              t.value
            ])
          )
        }),
        ...(spacingTokens.length > 0 && {
          spacing: Object.fromEntries(
            spacingTokens.map(t => [
              `${prefix}${sanitizeName(t.name)}`,
              t.value
            ])
          )
        }),
        ...(radiusTokens.length > 0 && {
          borderRadius: Object.fromEntries(
            radiusTokens.map(t => [
              `${prefix}${sanitizeName(t.name)}`,
              t.value
            ])
          )
        }),
        ...(shadowTokens.length > 0 && {
          boxShadow: Object.fromEntries(
            shadowTokens.map(t => [
              `${prefix}${sanitizeName(t.name)}`,
              t.value
            ])
          )
        }),
        ...(fontTokens.length > 0 && {
          fontFamily: Object.fromEntries(
            fontTokens.map(t => [
              `${prefix}${sanitizeName(t.name)}`,
              [t.value, 'sans-serif']
            ])
          )
        })
      }
    }
  }

  let output = includeComments
    ? `// Tailwind CSS Configuration\n// Generated by ContextDS\n\nmodule.exports = `
    : 'module.exports = '

  output += JSON.stringify(config, null, 2)

  return output
}

/**
 * Export tokens as CSS Custom Properties (CSS Variables)
 */
export function exportToCSSVariables(tokens: DesignToken[], options: TokenExportOptions = {}): string {
  const { prefix = '', includeComments = true } = options

  let css = includeComments
    ? `/* CSS Custom Properties */\n/* Generated by ContextDS */\n\n:root {\n`
    : ':root {\n'

  tokens.forEach(token => {
    const varName = `--${prefix}${sanitizeName(token.name)}`

    if (includeComments && token.usage) {
      css += `  /* ${token.name} - Used ${token.usage} times */\n`
    }

    css += `  ${varName}: ${token.value};\n`
  })

  css += '}\n'

  return css
}

/**
 * Export tokens as Figma Design Tokens JSON
 * Following the Figma Tokens plugin format
 */
export function exportToFigma(tokens: DesignToken[], options: TokenExportOptions = {}): string {
  const { includeComments = true } = options

  const figmaTokens: Record<string, any> = {}

  tokens.forEach(token => {
    const category = token.category
    if (!figmaTokens[category]) {
      figmaTokens[category] = {}
    }

    figmaTokens[category][sanitizeName(token.name)] = {
      value: token.value,
      type: mapCategoryToFigmaType(category),
      ...(includeComments && token.usage && {
        description: `Used ${token.usage} times${token.confidence ? ` Â· ${token.confidence}% confidence` : ''}`
      })
    }
  })

  return JSON.stringify(figmaTokens, null, 2)
}

/**
 * Export tokens as Style Dictionary format
 * Following Amazon's Style Dictionary structure
 */
export function exportToStyleDictionary(tokens: DesignToken[], options: TokenExportOptions = {}): string {
  const styleDictionary: Record<string, any> = {}

  tokens.forEach(token => {
    const parts = token.name.split('-')
    let current = styleDictionary

    // Create nested structure
    parts.forEach((part, index) => {
      const isLast = index === parts.length - 1

      if (isLast) {
        current[part] = {
          value: token.value,
          type: mapCategoryToStyleDictionaryType(token.category),
          ...(token.usage && { usage: token.usage }),
          ...(token.confidence && { confidence: token.confidence }),
          ...(token.semantic && { semantic: token.semantic })
        }
      } else {
        if (!current[part]) {
          current[part] = {}
        }
        current = current[part]
      }
    })
  })

  return JSON.stringify(styleDictionary, null, 2)
}

/**
 * Export tokens as SCSS Variables
 */
export function exportToSCSS(tokens: DesignToken[], options: TokenExportOptions = {}): string {
  const { prefix = '', includeComments = true } = options

  let scss = includeComments
    ? `// SCSS Variables\n// Generated by ContextDS\n\n`
    : ''

  tokens.forEach(token => {
    const varName = `$${prefix}${sanitizeName(token.name)}`

    if (includeComments && token.usage) {
      scss += `// ${token.name} - Used ${token.usage} times\n`
    }

    scss += `${varName}: ${token.value};\n`
  })

  return scss
}

/**
 * Utility: Sanitize token name for CSS/JS usage
 */
function sanitizeName(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, '-')
    .replace(/^-+|-+$/g, '')
    .replace(/-+/g, '-')
}

/**
 * Map internal category to Figma token type
 */
function mapCategoryToFigmaType(category: string): string {
  const mapping: Record<string, string> = {
    color: 'color',
    typography: 'fontFamily',
    spacing: 'spacing',
    radius: 'borderRadius',
    shadow: 'boxShadow',
    motion: 'duration'
  }

  return mapping[category] || 'other'
}

/**
 * Map internal category to Style Dictionary type
 */
function mapCategoryToStyleDictionaryType(category: string): string {
  const mapping: Record<string, string> = {
    color: 'color',
    typography: 'asset',
    spacing: 'dimension',
    radius: 'dimension',
    shadow: 'shadow',
    motion: 'time'
  }

  return mapping[category] || 'other'
}

/**
 * Get all available export formats
 */
export const EXPORT_FORMATS = [
  { id: 'tailwind', label: 'Tailwind Config', extension: 'js', exporter: exportToTailwind },
  { id: 'css', label: 'CSS Variables', extension: 'css', exporter: exportToCSSVariables },
  { id: 'figma', label: 'Figma Tokens', extension: 'json', exporter: exportToFigma },
  { id: 'style-dictionary', label: 'Style Dictionary', extension: 'json', exporter: exportToStyleDictionary },
  { id: 'scss', label: 'SCSS Variables', extension: 'scss', exporter: exportToSCSS },
] as const

export type ExportFormatId = typeof EXPORT_FORMATS[number]['id']